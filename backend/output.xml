This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-07-17 22:49:07

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
app.py
models
  database.py
  __init__.py
requirements.txt
routes
  players.py
  __init__.py
services
  scraper_service.py
  __init__.py
utils
  __init__.py
```

# Repository Files


## models/database.py

```python
# models/database.py - Configuraci√≥n y manejo de base de datos SQLite
# üî¥ ARCHIVO CR√çTICO - Base para todos los datos

import sqlite3
import os
from datetime import datetime

# üìç CONFIGURACI√ìN DE LA BASE DE DATOS
DATABASE_PATH = 'database.db'

def get_db():
    """
    Obtener conexi√≥n a la base de datos
    Equivalente a: const db = sqlite3.connect() en Node.js
    """
    try:
        conn = sqlite3.connect(DATABASE_PATH)
        conn.row_factory = sqlite3.Row  # Permite acceso por nombre de columna
        return conn
    except sqlite3.Error as e:
        print(f"‚ùå Error conectando a la base de datos: {e}")
        return None

def init_db():
    """
    Inicializar base de datos y crear tablas
    Se ejecuta al iniciar la aplicaci√≥n
    """
    print("üîß Inicializando base de datos...")
    
    conn = get_db()
    if conn is None:
        print("‚ùå No se pudo conectar a la base de datos")
        return False
    
    try:
        cursor = conn.cursor()
        
        # üéæ TABLA DE JUGADORES
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS players (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE,
                ranking INTEGER,
                country TEXT,
                age INTEGER,
                matches_played INTEGER DEFAULT 0,
                matches_won INTEGER DEFAULT 0,
                matches_lost INTEGER DEFAULT 0,
                win_percentage REAL DEFAULT 0.0,
                last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # üèÜ TABLA DE PARTIDOS
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS matches (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                player1_id INTEGER,
                player2_id INTEGER,
                player1_name TEXT,
                player2_name TEXT,
                winner_id INTEGER,
                score TEXT,
                tournament TEXT,
                date_played DATE,
                surface TEXT,
                round TEXT,
                duration INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (player1_id) REFERENCES players (id),
                FOREIGN KEY (player2_id) REFERENCES players (id),
                FOREIGN KEY (winner_id) REFERENCES players (id)
            )
        ''')
        
        # üèüÔ∏è TABLA DE TORNEOS (para futuro)
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS tournaments (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                location TEXT,
                surface TEXT,
                start_date DATE,
                end_date DATE,
                category TEXT,
                prize_money INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # üìä TABLA DE ESTAD√çSTICAS (para futuro)
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS player_stats (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                player_id INTEGER,
                season INTEGER,
                aces INTEGER DEFAULT 0,
                double_faults INTEGER DEFAULT 0,
                first_serve_percentage REAL DEFAULT 0.0,
                break_points_saved REAL DEFAULT 0.0,
                return_points_won REAL DEFAULT 0.0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (player_id) REFERENCES players (id)
            )
        ''')
        
        # üíæ CONFIRMAR CAMBIOS
        conn.commit()
        print("‚úÖ Tablas creadas correctamente:")
        print("   - players (jugadores)")
        print("   - matches (partidos)")
        print("   - tournaments (torneos)")
        print("   - player_stats (estad√≠sticas)")
        
        # üìã MOSTRAR TABLAS EXISTENTES
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = cursor.fetchall()
        print(f"üìä Tablas en la base de datos: {[table[0] for table in tables]}")
        
        return True
        
    except sqlite3.Error as e:
        print(f"‚ùå Error creando tablas: {e}")
        return False
    finally:
        conn.close()

def insert_player(name, ranking=None, country=None, age=None):
    """
    Insertar un jugador en la base de datos
    Par√°metros:
    - name: Nombre del jugador (obligatorio)
    - ranking: Posici√≥n en el ranking (opcional)
    - country: Pa√≠s (opcional)
    - age: Edad (opcional)
    """
    conn = get_db()
    if conn is None:
        return False
    
    try:
        cursor = conn.cursor()
        cursor.execute('''
            INSERT OR REPLACE INTO players 
            (name, ranking, country, age, last_updated) 
            VALUES (?, ?, ?, ?, ?)
        ''', (name, ranking, country, age, datetime.now()))
        
        conn.commit()
        player_id = cursor.lastrowid
        print(f"‚úÖ Jugador insertado: {name} (ID: {player_id})")
        return player_id
        
    except sqlite3.Error as e:
        print(f"‚ùå Error insertando jugador {name}: {e}")
        return False
    finally:
        conn.close()

def get_all_players():
    """
    Obtener todos los jugadores de la base de datos
    Retorna lista de diccionarios con informaci√≥n de jugadores
    """
    conn = get_db()
    if conn is None:
        return []
    
    try:
        cursor = conn.cursor()
        cursor.execute('''
            SELECT id, name, ranking, country, age, 
                   matches_played, matches_won, matches_lost, 
                   win_percentage, last_updated 
            FROM players 
            ORDER BY ranking ASC
        ''')
        
        players = []
        for row in cursor.fetchall():
            players.append({
                'id': row[0],
                'name': row[1],
                'ranking': row[2],
                'country': row[3],
                'age': row[4],
                'matches_played': row[5],
                'matches_won': row[6],
                'matches_lost': row[7],
                'win_percentage': row[8],
                'last_updated': row[9]
            })
        
        return players
        
    except sqlite3.Error as e:
        print(f"‚ùå Error obteniendo jugadores: {e}")
        return []
    finally:
        conn.close()

def get_player_by_name(name):
    """
    Buscar jugador por nombre
    """
    conn = get_db()
    if conn is None:
        return None
    
    try:
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM players WHERE name = ?', (name,))
        row = cursor.fetchone()
        
        if row:
            return {
                'id': row[0],
                'name': row[1],
                'ranking': row[2],
                'country': row[3],
                'age': row[4],
                'matches_played': row[5],
                'matches_won': row[6],
                'matches_lost': row[7],
                'win_percentage': row[8],
                'last_updated': row[9]
            }
        return None
        
    except sqlite3.Error as e:
        print(f"‚ùå Error buscando jugador {name}: {e}")
        return None
    finally:
        conn.close()

def update_player_stats(player_id, matches_played=None, matches_won=None, matches_lost=None):
    """
    Actualizar estad√≠sticas de un jugador
    """
    conn = get_db()
    if conn is None:
        return False
    
    try:
        cursor = conn.cursor()
        
        # Calcular porcentaje de victorias
        if matches_played and matches_won:
            win_percentage = (matches_won / matches_played) * 100
        else:
            win_percentage = 0.0
        
        cursor.execute('''
            UPDATE players 
            SET matches_played = ?, matches_won = ?, matches_lost = ?, 
                win_percentage = ?, last_updated = ?
            WHERE id = ?
        ''', (matches_played, matches_won, matches_lost, win_percentage, datetime.now(), player_id))
        
        conn.commit()
        return True
        
    except sqlite3.Error as e:
        print(f"‚ùå Error actualizando estad√≠sticas del jugador {player_id}: {e}")
        return False
    finally:
        conn.close()

# üß™ FUNCI√ìN DE PRUEBA
def test_database():
    """
    Probar que la base de datos funciona correctamente
    """
    print("üß™ Probando base de datos...")
    
    # Inicializar
    if not init_db():
        print("‚ùå Error inicializando base de datos")
        return
    
    # Insertar jugador de prueba
    player_id = insert_player("Carlos Alcaraz", ranking=1, country="Spain", age=21)
    if player_id:
        print(f"‚úÖ Jugador de prueba insertado (ID: {player_id})")
    
    # Obtener todos los jugadores
    players = get_all_players()
    print(f"üìä Jugadores en la base de datos: {len(players)}")
    for player in players:
        print(f"   - {player['name']} (#{player['ranking']})")

# üöÄ EJECUTAR PRUEBA SI SE EJECUTA DIRECTAMENTE
if __name__ == '__main__':
    test_database()
```

## models/__init__.py

```python

```

## requirements.txt

```text
Flask==2.3.3
requests==2.31.0
beautifulsoup4==4.12.2
selenium==4.15.2
pandas==2.0.3
flask-cors==4.0.0
python-dotenv==1.0.0
```

## routes/players.py

```python
# routes/players.py - Rutas de API para manejar jugadores
# üî¥ ARCHIVO CR√çTICO - API endpoints para jugadores

from flask import Blueprint, jsonify, request
from models.database import get_all_players, get_player_by_name, insert_player
from services.scraper_service import get_scraper, quick_scrape_top_10

# üèóÔ∏è CREAR BLUEPRINT
# Blueprint = m√≥dulo de rutas en Flask (equivalente a Router en Express.js)
players_bp = Blueprint('players', __name__)

# üìä RUTA: OBTENER TODOS LOS JUGADORES
@players_bp.route('/players', methods=['GET'])
def get_players():
    """
    GET /api/players
    Obtener lista de todos los jugadores
    Equivalente a: app.get('/api/players', (req, res) => {...}) en Node.js
    """
    try:
        # Obtener par√°metros de consulta
        limit = request.args.get('limit', type=int)
        country = request.args.get('country', type=str)
        
        # Obtener jugadores de la base de datos
        players = get_all_players()
        
        # Filtrar por pa√≠s si se especifica
        if country:
            players = [p for p in players if p['country'] and p['country'].lower() == country.lower()]
        
        # Limitar resultados si se especifica
        if limit and limit > 0:
            players = players[:limit]
        
        # Preparar respuesta
        response = {
            "success": True,
            "count": len(players),
            "players": players,
            "message": f"‚úÖ {len(players)} jugadores encontrados"
        }
        
        return jsonify(response), 200
        
    except Exception as e:
        return jsonify({
            "success": False,
            "error": str(e),
            "message": "‚ùå Error obteniendo jugadores"
        }), 500

# üîç RUTA: BUSCAR JUGADOR POR NOMBRE
@players_bp.route('/players/<string:player_name>', methods=['GET'])
def get_player(player_name):
    """
    GET /api/players/Carlos-Alcaraz
    Obtener informaci√≥n de un jugador espec√≠fico
    """
    try:
        # Limpiar nombre del jugador
        clean_name = player_name.replace('-', ' ').replace('_', ' ')
        
        # Buscar jugador en la base de datos
        player = get_player_by_name(clean_name)
        
        if player:
            return jsonify({
                "success": True,
                "player": player,
                "message": f"‚úÖ Jugador {clean_name} encontrado"
            }), 200
        else:
            return jsonify({
                "success": False,
                "message": f"‚ùå Jugador {clean_name} no encontrado"
            }), 404
            
    except Exception as e:
        return jsonify({
            "success": False,
            "error": str(e),
            "message": "‚ùå Error buscando jugador"
        }), 500

# üéæ RUTA: SCRAPING DEL TOP ATP
@players_bp.route('/players/scrape/atp-top', methods=['POST'])
def scrape_atp_top():
    """
    POST /api/players/scrape/atp-top
    Ejecutar scraping del top ATP y guardar en base de datos
    """
    try:
        # Obtener par√°metros del cuerpo de la petici√≥n
        data = request.get_json() or {}
        limit = data.get('limit', 10)  # Por defecto top 10
        
        # Validar l√≠mite
        if limit < 1 or limit > 100:
            return jsonify({
                "success": False,
                "message": "‚ùå L√≠mite debe estar entre 1 y 100"
            }), 400
        
        print(f"üöÄ Iniciando scraping del top {limit} ATP...")
        
        # Crear scraper y ejecutar
        scraper = get_scraper()
        result = scraper.scrape_and_save_atp_top(limit)
        
        if result:
            # Obtener jugadores actualizados
            players = get_all_players()
            
            return jsonify({
                "success": True,
                "message": f"‚úÖ Scraping completado exitosamente",
                "scraped_count": limit,
                "total_players": len(players),
                "players": players[:limit]  # Mostrar los primeros
            }), 200
        else:
            return jsonify({
                "success": False,
                "message": "‚ùå Error en el scraping"
            }), 500
            
    except Exception as e:
        return jsonify({
            "success": False,
            "error": str(e),
            "message": "‚ùå Error ejecutando scraping"
        }), 500

# üèÉ RUTA: SCRAPING R√ÅPIDO TOP 10
@players_bp.route('/players/scrape/quick', methods=['POST'])
def quick_scrape():
    """
    POST /api/players/scrape/quick
    Scraping r√°pido del top 10 ATP
    """
    try:
        print("‚ö° Iniciando scraping r√°pido del top 10...")
        
        # Ejecutar scraping r√°pido
        result = quick_scrape_top_10()
        
        if result:
            players = get_all_players()
            return jsonify({
                "success": True,
                "message": "‚ö° Scraping r√°pido completado",
                "players_count": len(players),
                "top_players": players[:10]
            }), 200
        else:
            return jsonify({
                "success": False,
                "message": "‚ùå Error en scraping r√°pido"
            }), 500
            
    except Exception as e:
        return jsonify({
            "success": False,
            "error": str(e),
            "message": "‚ùå Error en scraping r√°pido"
        }), 500

# ‚ûï RUTA: AGREGAR JUGADOR MANUALMENTE
@players_bp.route('/players', methods=['POST'])
def add_player():
    """
    POST /api/players
    Agregar jugador manualmente
    Body: {"name": "Rafael Nadal", "ranking": 2, "country": "Spain", "age": 37}
    """
    try:
        # Obtener datos del cuerpo de la petici√≥n
        data = request.get_json()
        
        if not data or 'name' not in data:
            return jsonify({
                "success": False,
                "message": "‚ùå Nombre del jugador es requerido"
            }), 400
        
        # Extraer datos
        name = data['name']
        ranking = data.get('ranking')
        country = data.get('country')
        age = data.get('age')
        
        # Insertar jugador
        player_id = insert_player(name, ranking, country, age)
        
        if player_id:
            # Obtener jugador insertado
            player = get_player_by_name(name)
            
            return jsonify({
                "success": True,
                "message": f"‚úÖ Jugador {name} agregado exitosamente",
                "player": player
            }), 201
        else:
            return jsonify({
                "success": False,
                "message": f"‚ùå Error agregando jugador {name}"
            }), 500
            
    except Exception as e:
        return jsonify({
            "success": False,
            "error": str(e),
            "message": "‚ùå Error agregando jugador"
        }), 500

# üìä RUTA: ESTAD√çSTICAS DE JUGADORES
@players_bp.route('/players/stats', methods=['GET'])
def get_players_stats():
    """
    GET /api/players/stats
    Obtener estad√≠sticas generales de jugadores
    """
    try:
        players = get_all_players()
        
        # Calcular estad√≠sticas
        total_players = len(players)
        countries = list(set([p['country'] for p in players if p['country']]))
        avg_age = sum([p['age'] for p in players if p['age']]) / len([p for p in players if p['age']]) if players else 0
        
        # Top 10 por ranking
        top_10 = [p for p in players if p['ranking'] and p['ranking'] <= 10]
        
        stats = {
            "total_players": total_players,
            "total_countries": len(countries),
            "countries": countries,
            "average_age": round(avg_age, 1),
            "top_10_count": len(top_10),
            "top_10_players": top_10
        }
        
        return jsonify({
            "success": True,
            "stats": stats,
            "message": "‚úÖ Estad√≠sticas calculadas correctamente"
        }), 200
        
    except Exception as e:
        return jsonify({
            "success": False,
            "error": str(e),
            "message": "‚ùå Error calculando estad√≠sticas"
        }), 500

# üîÑ RUTA: ACTUALIZAR JUGADOR
@players_bp.route('/players/<int:player_id>', methods=['PUT'])
def update_player(player_id):
    """
    PUT /api/players/1
    Actualizar informaci√≥n de un jugador
    """
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({
                "success": False,
                "message": "‚ùå Datos no proporcionados"
            }), 400
        
        # Aqu√≠ implementar√≠as la l√≥gica de actualizaci√≥n
        # Por ahora, solo devolvemos un mensaje
        return jsonify({
            "success": True,
            "message": f"‚úÖ Jugador {player_id} actualizado (funci√≥n en desarrollo)"
        }), 200
        
    except Exception as e:
        return jsonify({
            "success": False,
            "error": str(e),
            "message": "‚ùå Error actualizando jugador"
        }), 500

# üóëÔ∏è RUTA: ELIMINAR JUGADOR
@players_bp.route('/players/<int:player_id>', methods=['DELETE'])
def delete_player(player_id):
    """
    DELETE /api/players/1
    Eliminar un jugador
    """
    try:
        # Implementar l√≥gica de eliminaci√≥n
        return jsonify({
            "success": True,
            "message": f"‚úÖ Jugador {player_id} eliminado (funci√≥n en desarrollo)"
        }), 200
        
    except Exception as e:
        return jsonify({
            "success": False,
            "error": str(e),
            "message": "‚ùå Error eliminando jugador"
        }), 500

# üìù DOCUMENTACI√ìN DE RUTAS
"""
üìã RUTAS DISPONIBLES:

GET    /api/players              - Obtener todos los jugadores
GET    /api/players/stats        - Estad√≠sticas generales
GET    /api/players/<name>       - Buscar jugador por nombre
POST   /api/players              - Agregar jugador manualmente
POST   /api/players/scrape/atp-top - Scraping del top ATP
POST   /api/players/scrape/quick - Scraping r√°pido top 10
PUT    /api/players/<id>         - Actualizar jugador
DELETE /api/players/<id>         - Eliminar jugador

üîß EJEMPLOS DE USO:

# Obtener todos los jugadores
curl http://localhost:5000/api/players

# Obtener top 5 jugadores
curl http://localhost:5000/api/players?limit=5

# Buscar jugador espec√≠fico
curl http://localhost:5000/api/players/Carlos-Alcaraz

# Scraping r√°pido
curl -X POST http://localhost:5000/api/players/scrape/quick

# Scraping personalizado
curl -X POST http://localhost:5000/api/players/scrape/atp-top \
  -H "Content-Type: application/json" \
  -d '{"limit": 20}'
"""
```

## routes/__init__.py

```python

```

## services/scraper_service.py

```python
# services/scraper_service.py - Servicio de scraping de datos de tenis
# üî¥ ARCHIVO CR√çTICO - Extrae datos de Flashscore - VERSI√ìN CORREGIDA

import requests
from bs4 import BeautifulSoup
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException, WebDriverException
import time
import re
from datetime import datetime
import logging
import json

# üì¶ IMPORTAR FUNCIONES DE BASE DE DATOS
from models.database import insert_player, get_player_by_name, get_all_players

# üîß CONFIGURAR LOGGING
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class TennisScraperService:
    """
    Servicio para extraer datos de tenis desde Flashscore
    Versi√≥n corregida con selectores actualizados y mejor manejo de errores
    """
    
    def __init__(self):
        self.base_url = "https://www.flashscore.com"
        self.tennis_url = "https://www.flashscore.com/tennis/"
        self.driver = None
        self.max_retries = 3
        self.timeout = 15
        
    def setup_driver(self):
        """
        Configurar Chrome WebDriver para scraping con mejor configuraci√≥n
        """
        logger.info("üîß Configurando Chrome WebDriver...")
        
        try:
            # Configuraciones de Chrome mejoradas
            chrome_options = Options()
            chrome_options.add_argument("--headless")
            chrome_options.add_argument("--no-sandbox")
            chrome_options.add_argument("--disable-dev-shm-usage")
            chrome_options.add_argument("--disable-gpu")
            chrome_options.add_argument("--disable-blink-features=AutomationControlled")
            chrome_options.add_argument("--window-size=1920,1080")
            chrome_options.add_argument("--user-agent=Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36")
            chrome_options.add_argument("--accept-language=en-US,en;q=0.9")
            chrome_options.add_argument("--disable-web-security")
            chrome_options.add_argument("--allow-running-insecure-content")
            
            # Deshabilitar im√°genes para velocidad
            chrome_options.add_experimental_option("prefs", {
                "profile.managed_default_content_settings.images": 2,
                "profile.default_content_setting_values.notifications": 2
            })
            
            # Crear driver
            self.driver = webdriver.Chrome(options=chrome_options)
            self.driver.implicitly_wait(10)
            logger.info("‚úÖ Chrome WebDriver configurado correctamente")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error configurando Chrome WebDriver: {e}")
            return False
    
    def close_driver(self):
        """
        Cerrar el driver de Chrome de forma segura
        """
        try:
            if self.driver:
                self.driver.quit()
                logger.info("üîí Chrome WebDriver cerrado")
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error cerrando driver: {e}")
    
    def wait_for_element(self, selector, by=By.CSS_SELECTOR, timeout=None):
        """
        Esperar por un elemento con m√∫ltiples selectores de respaldo
        """
        if timeout is None:
            timeout = self.timeout
            
        try:
            wait = WebDriverWait(self.driver, timeout)
            element = wait.until(EC.presence_of_element_located((by, selector)))
            return element
        except TimeoutException:
            logger.warning(f"‚è∞ Timeout esperando elemento: {selector}")
            return None
    
    def scrape_atp_rankings(self, limit=50):
        """
        Scraping del ranking ATP desde Flashscore con selectores actualizados
        """
        logger.info(f"üéæ Scraping ranking ATP (top {limit})...")
        
        if not self.setup_driver():
            return {'success': False, 'error': 'No se pudo configurar el driver', 'data': []}
        
        try:
            # URL del ranking ATP
            ranking_url = f"{self.tennis_url}rankings/atp/"
            logger.info(f"üìç Accediendo a: {ranking_url}")
            
            self.driver.get(ranking_url)
            time.sleep(5)  # Esperar m√°s tiempo para la carga
            
            # Selectores actualizados para 2025
            possible_selectors = [
                "div[data-testid='wcl-table']",  # Nuevo selector
                ".wcl-table",
                "table.ui-table",
                ".table",
                ".rankings-table",
                "[class*='table']"
            ]
            
            table_element = None
            for selector in possible_selectors:
                table_element = self.wait_for_element(selector, timeout=5)
                if table_element:
                    logger.info(f"‚úÖ Tabla encontrada con selector: {selector}")
                    break
            
            if not table_element:
                logger.error("‚ùå No se encontr√≥ la tabla de rankings")
                return {'success': False, 'error': 'Tabla de rankings no encontrada', 'data': []}
            
            players_data = []
            
            # Selectores actualizados para filas de jugadores
            row_selectors = [
                "div[data-testid='wcl-table-row']",
                ".wcl-table-row",
                "tr.ui-table__row",
                "tr.table__row",
                ".ranking-row",
                "tr[class*='row']"
            ]
            
            player_rows = []
            for selector in row_selectors:
                try:
                    rows = self.driver.find_elements(By.CSS_SELECTOR, selector)
                    if rows:
                        player_rows = rows
                        logger.info(f"‚úÖ Filas encontradas con selector: {selector} ({len(rows)} filas)")
                        break
                except:
                    continue
            
            if not player_rows:
                logger.error("‚ùå No se encontraron filas de jugadores")
                return {'success': False, 'error': 'No se encontraron filas de jugadores', 'data': []}
            
            # Procesar jugadores
            for i, row in enumerate(player_rows[:limit]):
                try:
                    # M√∫ltiples selectores para cada campo
                    ranking_selectors = [
                        "[data-testid='wcl-rank']",
                        ".wcl-rank",
                        ".ui-table__body-cell--rank",
                        ".table__cell--rank",
                        ".rank"
                    ]
                    
                    name_selectors = [
                        "[data-testid='wcl-participant-name']",
                        ".wcl-participant-name",
                        ".ui-table__body-cell--participant",
                        ".table__cell--participant",
                        ".participant-name"
                    ]
                    
                    country_selectors = [
                        "[data-testid='wcl-flag']",
                        ".wcl-flag",
                        ".ui-table__body-cell--country",
                        ".table__cell--country",
                        ".country"
                    ]
                    
                    # Extraer ranking
                    ranking = None
                    for selector in ranking_selectors:
                        try:
                            ranking_element = row.find_element(By.CSS_SELECTOR, selector)
                            ranking_text = ranking_element.text.strip()
                            ranking = int(re.search(r'\d+', ranking_text).group()) if re.search(r'\d+', ranking_text) else None
                            if ranking:
                                break
                        except:
                            continue
                    
                    # Extraer nombre
                    name = None
                    for selector in name_selectors:
                        try:
                            name_element = row.find_element(By.CSS_SELECTOR, selector)
                            name = name_element.text.strip()
                            if name:
                                break
                        except:
                            continue
                    
                    # Si no encontramos nombre, intentar con el texto completo de la fila
                    if not name:
                        name = row.text.strip()
                        # Limpiar el nombre (remover n√∫meros y s√≠mbolos)
                        name = re.sub(r'^\d+\.?\s*', '', name)  # Remover ranking al inicio
                        name = re.sub(r'\s+\d+$', '', name)    # Remover puntos al final
                        name = name.split('\n')[0] if '\n' in name else name
                    
                    # Extraer pa√≠s
                    country = "Unknown"
                    for selector in country_selectors:
                        try:
                            country_element = row.find_element(By.CSS_SELECTOR, selector)
                            country = country_element.get_attribute('title') or country_element.text.strip() or "Unknown"
                            if country and country != "Unknown":
                                break
                        except:
                            continue
                    
                    # Validar datos m√≠nimos
                    if not ranking:
                        ranking = i + 1  # Usar √≠ndice como ranking de respaldo
                    
                    if not name or len(name) < 2:
                        logger.warning(f"‚ö†Ô∏è Nombre inv√°lido en fila {i+1}, saltando...")
                        continue
                    
                    # Extraer edad (opcional)
                    age = None
                    age_selectors = [
                        "[data-testid='wcl-age']",
                        ".wcl-age",
                        ".ui-table__body-cell--age",
                        ".table__cell--age"
                    ]
                    
                    for selector in age_selectors:
                        try:
                            age_element = row.find_element(By.CSS_SELECTOR, selector)
                            age_text = age_element.text.strip()
                            age = int(re.search(r'\d+', age_text).group()) if re.search(r'\d+', age_text) else None
                            if age:
                                break
                        except:
                            continue
                    
                    player_data = {
                        'ranking': ranking,
                        'name': name,
                        'country': country,
                        'age': age
                    }
                    
                    players_data.append(player_data)
                    logger.info(f"‚úÖ Jugador {i+1}: {name} (#{ranking}) - {country}")
                    
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Error procesando jugador {i+1}: {e}")
                    continue
            
            if players_data:
                logger.info(f"üìä Scraping completado: {len(players_data)} jugadores extra√≠dos")
                return {'success': True, 'data': players_data, 'count': len(players_data)}
            else:
                logger.error("‚ùå No se pudieron extraer datos de jugadores")
                return {'success': False, 'error': 'No se pudieron extraer datos', 'data': []}
            
        except Exception as e:
            logger.error(f"‚ùå Error en scraping ATP rankings: {e}")
            return {'success': False, 'error': f'Error en scraping: {str(e)}', 'data': []}
        finally:
            self.close_driver()
    
    def scrape_player_matches(self, player_name, limit=10):
        """
        Scraping de partidos recientes de un jugador
        """
        logger.info(f"üéæ Scraping partidos de {player_name}...")
        
        if not self.setup_driver():
            return {'success': False, 'error': 'No se pudo configurar el driver', 'data': []}
        
        try:
            # Buscar jugador en Flashscore
            search_query = player_name.replace(' ', '+')
            search_url = f"{self.base_url}/search/?q={search_query}"
            logger.info(f"üîç Buscando: {search_url}")
            
            self.driver.get(search_url)
            time.sleep(3)
            
            # Buscar primer resultado
            result_selectors = [
                "[data-testid='search-result-participant']",
                ".search-result__participant",
                ".searchResult__participant",
                ".search-participant",
                "a[href*='tennis']"
            ]
            
            first_result = None
            for selector in result_selectors:
                try:
                    first_result = self.driver.find_element(By.CSS_SELECTOR, selector)
                    if first_result:
                        break
                except:
                    continue
            
            if not first_result:
                logger.error(f"‚ùå No se encontr√≥ el jugador {player_name}")
                return {'success': False, 'error': f'Jugador {player_name} no encontrado', 'data': []}
            
            first_result.click()
            time.sleep(3)
            
            # Buscar secci√≥n de resultados
            results_selectors = [
                "a[href*='results']",
                "a[data-testid='results-tab']",
                "a[text()='Results']",
                ".results-tab"
            ]
            
            results_tab = None
            for selector in results_selectors:
                try:
                    results_tab = self.driver.find_element(By.CSS_SELECTOR, selector)
                    if results_tab:
                        break
                except:
                    continue
            
            if results_tab:
                results_tab.click()
                time.sleep(2)
            
            matches_data = []
            
            # Buscar partidos
            match_selectors = [
                "[data-testid='match-row']",
                ".match-row",
                ".tennis-match",
                ".ui-table__row"
            ]
            
            match_rows = []
            for selector in match_selectors:
                try:
                    rows = self.driver.find_elements(By.CSS_SELECTOR, selector)
                    if rows:
                        match_rows = rows
                        break
                except:
                    continue
            
            for i, match in enumerate(match_rows[:limit]):
                try:
                    match_text = match.text.strip()
                    if match_text:
                        # Parsear informaci√≥n b√°sica del partido
                        match_data = {
                            'date': 'N/A',
                            'opponent': 'N/A',
                            'score': 'N/A',
                            'tournament': 'N/A',
                            'raw_text': match_text
                        }
                        
                        matches_data.append(match_data)
                        logger.info(f"‚úÖ Partido {i+1}: {match_text[:50]}...")
                    
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Error procesando partido {i+1}: {e}")
                    continue
            
            return {'success': True, 'data': matches_data, 'count': len(matches_data)}
            
        except Exception as e:
            logger.error(f"‚ùå Error scraping partidos de {player_name}: {e}")
            return {'success': False, 'error': f'Error scraping partidos: {str(e)}', 'data': []}
        finally:
            self.close_driver()
    
    def save_players_to_database(self, players_data):
        """
        Guardar jugadores scrapeados en la base de datos con mejor manejo de errores
        """
        logger.info("üíæ Guardando jugadores en la base de datos...")
        
        if not players_data:
            logger.warning("‚ö†Ô∏è No hay datos de jugadores para guardar")
            return {'success': False, 'saved_count': 0, 'errors': ['No hay datos para guardar']}
        
        saved_count = 0
        errors = []
        
        for player in players_data:
            try:
                # Validar datos del jugador
                if not player.get('name') or len(player['name']) < 2:
                    errors.append(f"Nombre inv√°lido: {player.get('name', 'N/A')}")
                    continue
                
                player_id = insert_player(
                    name=player['name'],
                    ranking=player.get('ranking', 0),
                    country=player.get('country', 'Unknown'),
                    age=player.get('age')
                )
                
                if player_id:
                    saved_count += 1
                    logger.info(f"‚úÖ Guardado: {player['name']}")
                else:
                    errors.append(f"No se pudo guardar: {player['name']}")
                    
            except Exception as e:
                error_msg = f"Error guardando {player.get('name', 'N/A')}: {str(e)}"
                errors.append(error_msg)
                logger.error(f"‚ùå {error_msg}")
        
        logger.info(f"üìä Guardado completado: {saved_count} jugadores guardados")
        
        return {
            'success': saved_count > 0,
            'saved_count': saved_count,
            'errors': errors,
            'total_attempted': len(players_data)
        }
    
    def scrape_and_save_atp_top(self, limit=50):
        """
        Scraping completo: extraer y guardar top ATP con mejor manejo de errores
        """
        logger.info(f"üöÄ Iniciando scraping completo del top {limit} ATP...")
        
        try:
            # Scraping
            scrape_result = self.scrape_atp_rankings(limit)
            
            if not scrape_result['success']:
                logger.error(f"‚ùå Error en scraping: {scrape_result['error']}")
                return {
                    'success': False,
                    'error': scrape_result['error'],
                    'scraped_count': 0,
                    'saved_count': 0
                }
            
            players_data = scrape_result['data']
            
            if not players_data:
                logger.error("‚ùå No se pudieron extraer datos")
                return {
                    'success': False,
                    'error': 'No se pudieron extraer datos',
                    'scraped_count': 0,
                    'saved_count': 0
                }
            
            # Guardar en base de datos
            save_result = self.save_players_to_database(players_data)
            
            result = {
                'success': save_result['success'],
                'scraped_count': len(players_data),
                'saved_count': save_result['saved_count'],
                'errors': save_result.get('errors', [])
            }
            
            if save_result['success']:
                logger.info(f"üéâ Scraping completado exitosamente: {save_result['saved_count']} jugadores guardados")
            else:
                logger.error(f"‚ùå Error guardando datos: {save_result['errors']}")
                result['error'] = 'Error guardando en base de datos'
            
            return result
            
        except Exception as e:
            logger.error(f"‚ùå Error en scrape_and_save_atp_top: {e}")
            return {
                'success': False,
                'error': f'Error inesperado: {str(e)}',
                'scraped_count': 0,
                'saved_count': 0
            }

# üè≠ FUNCIONES AUXILIARES MEJORADAS
def get_scraper():
    """
    Crear instancia del scraper
    """
    return TennisScraperService()

def quick_scrape_top_10():
    """
    Funci√≥n r√°pida para scrapear el top 10 ATP con manejo de errores
    """
    try:
        scraper = get_scraper()
        return scraper.scrape_and_save_atp_top(10)
    except Exception as e:
        logger.error(f"‚ùå Error en quick_scrape_top_10: {e}")
        return {
            'success': False,
            'error': f'Error inesperado: {str(e)}',
            'scraped_count': 0,
            'saved_count': 0
        }

def scrape_player(player_name):
    """
    Scrapear informaci√≥n de un jugador espec√≠fico
    """
    try:
        scraper = get_scraper()
        return scraper.scrape_player_matches(player_name)
    except Exception as e:
        logger.error(f"‚ùå Error scraping jugador {player_name}: {e}")
        return {
            'success': False,
            'error': f'Error inesperado: {str(e)}',
            'data': []
        }

# üß™ FUNCI√ìN DE PRUEBA MEJORADA
def test_scraper():
    """
    Probar el scraper con datos reales y mejor reporte
    """
    logger.info("üß™ Probando scraper de tenis...")
    
    try:
        # Crear scraper
        scraper = TennisScraperService()
        
        # Probar scraping del top 5
        logger.info("1. Probando scraping del top 5 ATP...")
        result = scraper.scrape_and_save_atp_top(5)
        
        print(f"üìä Resultado del scraping:")
        print(f"   - √âxito: {result['success']}")
        print(f"   - Jugadores scrapeados: {result['scraped_count']}")
        print(f"   - Jugadores guardados: {result['saved_count']}")
        
        if result.get('errors'):
            print(f"   - Errores: {len(result['errors'])}")
            for error in result['errors'][:3]:  # Mostrar solo los primeros 3
                print(f"     * {error}")
        
        if result['success']:
            logger.info("‚úÖ Scraping exitoso")
            
            # Mostrar jugadores guardados
            try:
                players = get_all_players()
                print(f"üìà Jugadores en la base de datos: {len(players)}")
                for player in players[:5]:
                    print(f"   - {player['name']} (#{player['ranking']}) - {player['country']}")
            except Exception as e:
                logger.error(f"‚ùå Error obteniendo jugadores de la BD: {e}")
        else:
            logger.error(f"‚ùå Error en scraping: {result.get('error', 'Error desconocido')}")
            
    except Exception as e:
        logger.error(f"‚ùå Error en test_scraper: {e}")
        print(f"üí• Error general: {e}")

# üöÄ EJECUTAR PRUEBA SI SE EJECUTA DIRECTAMENTE
if __name__ == '__main__':
    test_scraper()
```

## services/__init__.py

```python

```

## utils/__init__.py

```python

```

## Statistics

- Total Files: 8
- Total Characters: 46231
- Total Tokens: 0
